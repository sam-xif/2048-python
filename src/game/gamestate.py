"""
Defines a representation of 2048's game state.
"""

import random
import src.game.constants as c, src.game.logic as logic
import numpy as np


class BaseGameState:
    """
    Abstract base class that defines an interface for interacting with the 2048 game state
    """

    def get_score(self):
        return NotImplemented
    #
    # def get_matrix(self):
    #     return NotImplemented
    #
    # def same_matrix(self, other):
    #     np_arr1 = np.array(self.get_matrix())
    #     np_arr2 = np.array(other.get_matrix())
    #     return np.equal()

    def get_successors(self, agent_id):
        """
        Get successor states from the current state. Each successor state is generated by the given agent taking one of
          the allowed actions.
        :param agent_id: constants.PLAYER for the player, constants.ADVERSARY represents the "opponent"
          that places 2 or 4 squares randomly.
        :return: A list of BaseGameState objects representing the successor states
        """
        return NotImplemented

    def get_successor(self, action, agent_id):
        return NotImplemented

    def get_allowed_actions(self, agent_id):
        """
        Gets allowed actions that the given agent can take for the current state
        :param agent_id: Either PLAYER or ADVERSARY
        :return: List of actions (integer constants)
        """
        return NotImplemented

    def execute_action(self, action, agent_id) -> None:
        """
        Executes an action.
        :param action: The action to execute
        :param agent_id: The ID of the agent that will be executing the action
        :raises: ValueError: if the given action cannot be taken by the given agent.
        :return:
        """
        return NotImplemented

    def state(self):
        """
        Returns whether the game has been won, lost, or is not over yet
        :return: string of form: 'win' | 'lose' | 'not over'
        """
        return NotImplemented

    def left(self):
        """
        Shortcut for the player taking action LEFT
        :return:
        """
        return self.execute_action(c.ACTION_LEFT, c.PLAYER)

    def right(self):
        """
        Shortcut for the player taking action RIGHT
        :return:
        """
        return self.execute_action(c.ACTION_RIGHT, c.PLAYER)

    def up(self):
        """
        Shortcut for the player taking action UP
        :return:
        """
        return self.execute_action(c.ACTION_UP, c.PLAYER)

    def down(self):
        """
        Shortcut for the player taking action DOWN
        :return:
        """
        return self.execute_action(c.ACTION_DOWN, c.PLAYER)

    def add_new_tile(self):
        """
        Shortcut for the adversary taking a PLACE action at a random square. If there are no blank squares available,
        this method does nothing.
        :return: None
        """

        # Get allowed actions for the adversary
        # Each action corresponds to placing a 2 or 4 at an open square
        actions = self.get_allowed_actions(c.ADVERSARY)

        if len(actions) < 1:
            return

        # Execute a random one of these actions
        return self.execute_action(random.choice(actions), c.ADVERSARY)

    def toString(self):
        return NotImplemented


class CloneableGameState(BaseGameState):
    def clone(self):
        """
        Return a copy of this game state
        :return:
        """
        return NotImplemented

    def get_successors(self, agent_id):
        """
        (This can now be implemented with clone)
        :return:
        """
        successors = []

        if self.state() != 'not over':
            return successors  # return empty list when no more moves can be made

        for action in self.get_allowed_actions(agent_id):
            cln: CloneableGameState = self.clone()
            cln.execute_action(action, agent_id)
            successors.append(cln)

        return successors

    def get_successor(self, action, agent_id):
        cln: CloneableGameState = self.clone()
        cln.execute_action(action, agent_id)
        return cln


class GameStateImpl(CloneableGameState):
    def __init__(self):
        super().__init__()
        self.init_matrix()
        self.score = 0

        self.commands = {c.ACTION_UP: logic.up,
                         c.ACTION_DOWN: logic.down,
                         c.ACTION_LEFT: logic.left,
                         c.ACTION_RIGHT: logic.right}

    def get_score(self):
        return self.score

    def clone(self):
        gs = GameStateImpl()
        gs.matrix = [x[:] for x in self.matrix]
        gs.history_matrixs = self.history_matrixs[:]
        gs.score = self.score
        return gs

    def init_matrix(self):
        self.matrix = logic.new_game(c.GRID_LEN)
        self.history_matrixs = list()
        self.matrix = logic.add_two(self.matrix)
        self.matrix = logic.add_two(self.matrix)

    def state(self):
        return logic.game_state(self.matrix)

    def execute_action(self, action, agent_id):
        # key = repr(event.char)
        # if key == c.KEY_BACK and len(self.history_matrixs) > 1:
        #     self.matrix = self.history_matrixs.pop()
        #     self.update_grid_cells()
        #     print('back on step total step:', len(self.history_matrixs))
        if self.state() != 'not over':
            return

        if agent_id == c.PLAYER:
            if action in self.commands:
                self.matrix, done, scored = self.commands[action](self.matrix)
                if done:
                    # self.matrix = logic.add_two(self.matrix)
                    # record last move
                    self.history_matrixs.append(self.matrix)
                    self.score += scored
                return done
        elif agent_id == c.ADVERSARY:
            # In this case, expect the action to be a tuple of blank (x, y)
            x, y = action

            if self.matrix[x][y] != 0:
                raise ValueError("Action is not valid")

            self.matrix[x][y] = 2  # Just add 2's for now, maybe add 4's later
            self.history_matrixs.append(self.matrix)
            return True
        else:
            raise ValueError('Unrecognized agent ID')

    def _mats_eq(self, mat1, mat2):
        for i in range(4):
            for j in range(4):
                if mat1[i][j] != mat2[i][j]:
                    return False
        return True

    def get_allowed_actions(self, agent_id):
        """
        Override method
        :param agent_id:
        :return:
        """
        if self.state() != 'not over':
            return []

        if agent_id == c.PLAYER:
            possible_actions = [c.ACTION_LEFT, c.ACTION_UP, c.ACTION_DOWN, c.ACTION_RIGHT]
            available_actions = []
            for action in possible_actions:
                succ = self.get_successor(action, agent_id)
                if not self._mats_eq(succ.matrix, self.matrix):
                    # That means something changed, so permit this action only in this case to prevent our agent from stalling
                    available_actions.append(action)

            return available_actions
        elif agent_id == c.ADVERSARY:
            actions = []
            for i in range(len(self.matrix)):
                for j in range(len(self.matrix[0])):
                    if self.matrix[i][j] == 0:
                        actions.append((i, j))
            return actions
        else:
            raise ValueError('Unrecognized agent ID')
    
    def toString(self):
        return ','.join(str(item) for row in self.matrix for item in row)
